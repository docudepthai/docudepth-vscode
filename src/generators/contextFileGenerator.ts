import * as fs from 'fs';
import * as path from 'path';
import { ContextMap } from '../types';

/**
 * Generates context files for various AI coding assistants
 * These files are automatically read by each tool to provide codebase context
 */
export class ContextFileGenerator {
  private workspaceRoot: string;

  constructor(workspaceRoot: string) {
    this.workspaceRoot = workspaceRoot;
  }

  /**
   * Generate all AI tool context files from the context map
   */
  async generateAll(contextMap: ContextMap): Promise<void> {
    const contextContent = this.formatContextContent(contextMap);

    await Promise.all([
      this.generateClaudeCode(contextContent),
      this.generateCursor(contextContent),
      this.generateWindsurf(contextContent),
      this.generateCopilot(contextContent),
      this.generateContinue(contextContent),
      this.generateAider(contextContent),
    ]);

    console.log('[DocuDepth] Generated context files for all AI tools');
  }

  /**
   * Format context map into readable content for AI tools
   */
  private formatContextContent(contextMap: ContextMap): string {
    const { repository, architecture, modules, patterns, files } = contextMap;

    let content = `# Codebase Context Map\n\n`;
    content += `> Generated by DocuDepth AI - https://docudepthai.com\n`;
    content += `> Last updated: ${new Date().toISOString()}\n\n`;

    // Repository Overview
    content += `## Project Overview\n\n`;
    content += `**${repository.name}**\n\n`;
    if (repository.description) {
      content += `${repository.description}\n\n`;
    }
    content += `- **Primary Language:** ${repository.primaryLanguage}\n`;
    if (repository.framework) {
      content += `- **Framework:** ${repository.framework}\n`;
    }
    content += `- **Total Files:** ${repository.totalFiles}\n\n`;

    // Architecture
    content += `## Architecture\n\n`;
    content += `**Style:** ${architecture.style}\n\n`;
    content += `${architecture.summary}\n\n`;

    // Modules
    if (modules && modules.length > 0) {
      content += `## Modules\n\n`;
      for (const module of modules) {
        content += `### ${module.name}\n\n`;
        content += `- **Path:** \`${module.path}\`\n`;
        content += `- **Purpose:** ${module.purpose}\n`;
        if (module.publicAPI && module.publicAPI.length > 0) {
          content += `- **Key Exports:** ${module.publicAPI.slice(0, 10).join(', ')}\n`;
        }
        if (module.dependencies && module.dependencies.length > 0) {
          content += `- **Dependencies:** ${module.dependencies.slice(0, 5).join(', ')}\n`;
        }
        content += `\n`;
      }
    }

    // Key Files (from files record)
    if (files && Object.keys(files).length > 0) {
      content += `## Key Files\n\n`;
      const fileEntries = Object.values(files).slice(0, 20);
      for (const file of fileEntries) {
        content += `- \`${file.path}\` - ${file.purpose}\n`;
      }
      content += `\n`;
    }

    // Patterns
    if (patterns && patterns.length > 0) {
      content += `## Code Patterns & Conventions\n\n`;
      for (const pattern of patterns) {
        content += `### ${pattern.name}\n\n`;
        content += `${pattern.description}\n\n`;
        if (pattern.files && pattern.files.length > 0) {
          content += `**Used in:** ${pattern.files.slice(0, 3).join(', ')}\n\n`;
        }
      }
    }

    // Usage instructions
    content += `---\n\n`;
    content += `## How to Use This Context\n\n`;
    content += `This file provides your AI coding assistant with deep understanding of this codebase.\n`;
    content += `The AI will automatically use this context to:\n\n`;
    content += `- Understand the project structure and architecture\n`;
    content += `- Follow existing code patterns and conventions\n`;
    content += `- Make accurate suggestions that fit the codebase\n`;
    content += `- Navigate between related files and modules\n\n`;
    content += `*This file is auto-generated and updated by DocuDepth. Do not edit manually.*\n`;

    return content;
  }

  /**
   * Generate CLAUDE.md for Claude Code
   */
  private async generateClaudeCode(content: string): Promise<void> {
    const claudeContent = `${content}`;
    const filePath = path.join(this.workspaceRoot, 'CLAUDE.md');
    fs.writeFileSync(filePath, claudeContent, 'utf-8');
  }

  /**
   * Generate .cursorrules for Cursor
   */
  private async generateCursor(content: string): Promise<void> {
    // Cursor expects a slightly different format - more directive
    let cursorContent = `# Cursor Rules - Generated by DocuDepth\n\n`;
    cursorContent += `You are working on a codebase with the following structure and conventions.\n`;
    cursorContent += `Always follow the patterns and architecture described below.\n\n`;
    cursorContent += content;

    const filePath = path.join(this.workspaceRoot, '.cursorrules');
    fs.writeFileSync(filePath, cursorContent, 'utf-8');
  }

  /**
   * Generate .windsurfrules for Windsurf
   */
  private async generateWindsurf(content: string): Promise<void> {
    let windsurfContent = `# Windsurf Rules - Generated by DocuDepth\n\n`;
    windsurfContent += content;

    const filePath = path.join(this.workspaceRoot, '.windsurfrules');
    fs.writeFileSync(filePath, windsurfContent, 'utf-8');
  }

  /**
   * Generate .github/copilot-instructions.md for GitHub Copilot
   */
  private async generateCopilot(content: string): Promise<void> {
    const githubDir = path.join(this.workspaceRoot, '.github');

    // Create .github directory if it doesn't exist
    if (!fs.existsSync(githubDir)) {
      fs.mkdirSync(githubDir, { recursive: true });
    }

    let copilotContent = `# GitHub Copilot Instructions - Generated by DocuDepth\n\n`;
    copilotContent += content;

    const filePath = path.join(githubDir, 'copilot-instructions.md');
    fs.writeFileSync(filePath, copilotContent, 'utf-8');
  }

  /**
   * Generate .continuerules for Continue.dev
   */
  private async generateContinue(content: string): Promise<void> {
    let continueContent = `# Continue Rules - Generated by DocuDepth\n\n`;
    continueContent += content;

    const filePath = path.join(this.workspaceRoot, '.continuerules');
    fs.writeFileSync(filePath, continueContent, 'utf-8');
  }

  /**
   * Generate .aider/context.md for Aider
   */
  private async generateAider(content: string): Promise<void> {
    const aiderDir = path.join(this.workspaceRoot, '.aider');

    // Create .aider directory if it doesn't exist
    if (!fs.existsSync(aiderDir)) {
      fs.mkdirSync(aiderDir, { recursive: true });
    }

    let aiderContent = `# Aider Context - Generated by DocuDepth\n\n`;
    aiderContent += content;

    const filePath = path.join(aiderDir, 'context.md');
    fs.writeFileSync(filePath, aiderContent, 'utf-8');
  }
}
